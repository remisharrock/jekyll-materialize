[{"authors":["admin"],"categories":null,"content":"I\u0026rsquo;m a researcher and an associate professor working for Telecom Paris. My research team is called DIVA, we are a member of the LTCI research lab. Let me give you some of my research questions :\n What are the conceptual and technological limits of large scale distributed systems ? How to leverage technology-mediated learning environments to enhance human learning ? What is the impact of large scale learning systems in the global education ? What are the best practices in learning ecosystems to acheive equity ? How do you take into account the human feedback in AI algorithms / autonomic systems / smart-systems ?  ","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://remisharrock.fr/author/remi-sharrock/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/remi-sharrock/","section":"authors","summary":"I\u0026rsquo;m a researcher and an associate professor working for Telecom Paris. My research team is called DIVA, we are a member of the LTCI research lab. Let me give you some of my research questions :","tags":null,"title":"Rémi SHARROCK","type":"authors"},{"authors":null,"categories":null,"content":"Objectifs pédagogiques Ce cours se présente sous la forme de Travaux Pratiques guidés. Vous utiliserez plusieurs ordinateurs connectés en réseaux et le langage de programmation Java pour implémenter une version simple du concept MapReduce. L\u0026rsquo;implémentation la plus connue est également codée en Java, il s\u0026rsquo;agit de Hadoop. Vous visualiserez la Loi d\u0026rsquo;Ahmdal et la démontrerez empiriquement. Vous implémenterez le concept MapReduce et définirez une architecture répartie. Vous comparerez cette architecture répartie en terme de performances avec une architecture non répartie, séquentielle et en tirerez des conclusions.\nPréparez un document de travail qu\u0026rsquo;il faudra rendre à la fin de l\u0026rsquo;unité d\u0026rsquo;enseignement. Créez un document dans lequel vous allez expliquer votre implémentation au fur et à mesure, les problèmes rencontrés, les solutions innovantes, vos idées et réflexions, vos pistes d\u0026rsquo;améliorations. Il s\u0026rsquo;agit plutôt d\u0026rsquo;écrire ce qui vous étonne et ce que vous avez appris d\u0026rsquo;intéressant plutôt que de répondre de manière directe aux questions posées. Les questions dans les étapes de mise en place du projet n\u0026rsquo;ont pas besoin de réponse dans ce document, uniquement celles faisant référence à l\u0026rsquo;implémentation de votre projet et aux résultats de calcul obtenus ainsi que les discussions autour de ces résultats. Ce document sera un rapport de travail qu\u0026rsquo;il faut rendre à la fin du cours.\nChronométrage et justification de la loi d\u0026rsquo;Ahmdal. Tout le long du projet, vous obtiendrez des mesures de chronométrage et calculerez différents \u0026ldquo;speedup\u0026rdquo; (des accélérations) pour en déduire des taux de parallélisation (c\u0026rsquo;est à dire la portion de code parallèle). Pour chaque nouvelle mesure, vous devez exploiter ces mesures et les discuter. Évidemment, pour obtenir une accélération il faut comparer deux systèmes et les comparer dans des conditions les plus similaires possibles, c\u0026rsquo;est à dire à minima avec le même jeu de donnée en entrée et en prouvant que vous avez le même résultat en sortie. Pour prouver que vous obtenez le même résultat en sortie avec deux systèmes différents, vous utiliserez un troisième système (un outil/logiciel que vous trouverez vous-même) qui fait le même calcul (par exemple la fréquence des mots) et piocherez au hasard des mots pour savoir si dans le cas du système 1 et dans le cas du système 2 vous avez les même résultats.\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"6cd59f080c44e356026e646973c26b4b","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/","section":"courses","summary":"Dans ce cours, vous apprendrez à implémenter une version simple du concept MapReduce en partant de zéro. C'est une sorte de ré-implémentation de Hadoop, codé en langage Java.","tags":null,"title":"Travaux pratiques - implémentation de Hadoop MapReduce \"from scratch\" en Java.","type":"docs"},{"authors":null,"categories":null,"content":"Faire un programme séquentiel non parallélisé qui compte le nombre d'occurrences des mots dans un fichier. Prérequis et documentation   programmer en Java\nhttps://perso.telecom-paristech.fr/bellot/CoursJava/\n  manipuler l\u0026rsquo;environnement de développement Eclipse\nhttps://perso.telecom-paristech.fr/bellot/CoursJava/tps/\n  lire et écrire dans un fichier en java\nhttps://perso.telecom-paristech.fr/bellot/CoursJava/JavaIO.html\n  Premier comptage en séquentiel pur Implémentez un logiciel en java qui compte le nombre d\u0026rsquo;occurrences des mots d\u0026rsquo;un fichier d\u0026rsquo;entrée de manière non parallélisée (monothread, une seul thread), en utilisant un seul processeur.\nQuelle structure de donnée est la plus pertinente pour stocker les résultats: List, HashMap ou HashSet ou une autre ? Pour quelle raison ?\nTestez votre programme avec un fichier d\u0026rsquo;entrée input.txt avec comme contenu:\nDeer Beer River\nCar Car River\nDeer Car Beer\nRésultat:\nDeer 2\nBeer 2\nRiver 2\nCar 3\nPremier tri en séquentiel pur Modifiez votre programme pour trier par nombre d'occurrences:\nRésultat:\nCar 3\nDeer 2\nBeer 2\nRiver 2\nDeuxième tri alphabétique en séquentiel pur Modifiez le programme pour trier alphabétiquement pour les mots à égalité du nombre d\u0026rsquo;occurrences:\nRésultat:\nCar 3\nBeer 2\nDeer 2\nRiver 2\nTest du programme séquentiel sur le code forestier de Mayotte Testez ensuite votre programme avec le code forestier de Mayotte disponible sur github forestier_mayotte.txt :\nhttps://github.com/legifrance/Les-codes-en-vigueur\nVotre programme a-t-il fonctionné du premier coup ?\nVérifiez en ouvrant le fichier texte qu\u0026rsquo;il contient bien du texte et non du code HTML.\nNe perdez pas de temps à corriger les éventuelles erreurs dues aux caractères spéciaux ou à des mots suspects ou illisibles (de toutes façons par la suite il y aura du chinois dans le texte). Les 50 mots du code de la déontologie de la police nationale Testez votre programme avec le code de déontologie de la police nationale disponible sur github deontologie_police_nationale.txt : https://github.com/legifrance/Les-codes-en-vigueur\nDe même ne perdez pas de temps à filtrer les caractères spéciaux ou autres mots bizarres. Pourquoi ? Car nous travaillerons ensuite sur des textes en chinois, japonais, arabe et d\u0026rsquo;autres langues. Si vous implémentez une étape de filtrage ici en français elle ne servira à rien par la suite. Quels sont les 5 premiers mots (qui ressemblent à des mots) parmi les 50 premiers de la liste triée résultat ? Gardez la réponse pour l\u0026rsquo;intégrer au rapport.\nLes 50 mots du code du domaine public fluvial  Testez votre programme avec le code du domaine public fluvial domaine_public_fluvial.txt.\nQuels sont les 5 premiers mots (qui ressemblent à des mots) parmi les 50 premiers de la liste triée résultat ? Gardez la réponse pour l\u0026rsquo;intégrer au rapport.\nLes 50 mots du code de la santé publique Testez votre programme avec le code de la santé publique sante_publique.txt.\nQuels sont les 5 premiers mots (qui ressemblent à des mots) parmi les 50 premiers de la liste triée résultat ? Gardez la réponse pour l\u0026rsquo;intégrer au rapport.\nChronométrage du programme séquentiel Chronométrer votre programme sur le code de la santé publique.\nChronométrage possible avec:\nlong startTime = System.currentTimeMillis();\n...\nlong endTime = System.currentTimeMillis();\nlong totalTime = endTime - startTime;\nCombien de temps faut-il pour chacune des étapes:\n  Compter le nombre d\u0026rsquo;occurrences\n  Tri (par nombre d'occurrences et alphabétique)\n  Gardez la réponse pour l\u0026rsquo;intégrer au rapport.\nTravailler sur des plus gros fichiers Testez votre programme sur un cas réel: un extrait de toutes les pages internet transformées au format texte brut (format WET). Toutes les pages sur internet au format texte sont disponibles sur http://commoncrawl.org/the-data/get-started/ : chaque mois, environ 3 milliards de pages web, soit 250 To de données sont stockées. Ces données sont disponibles par tranche de moins d'1Go environ, vous travaillerez sur une tranche de 380Mo.\nJ\u0026rsquo;ai choisi une tranche en particulier pour avoir une comparaison entre nous (vous pouvez tester sur d\u0026rsquo;autres tranches si vous voulez). Téléchargez cette tranche ici:\nhttps://commoncrawl.s3.amazonaws.com/crawl-data/CC-MAIN-2017-13/segments/1490218189495.77/wet/CC-MAIN-20170322212949-00140-ip-10-233-31-227.ec2.internal.warc.wet.gz Décompressez et obtenez le fichier CC-MAIN-20170322212949-00140-ip-10-233-31-227.ec2.internal.warc.wet Il s\u0026rsquo;agit d\u0026rsquo;une tranche contenant un ensemble de sites internet au format texte brut (WET).\nTestez votre programme avec ce fichier en entrée. Chronométrez-le.\nGardez la réponse pour l\u0026rsquo;intégrer au rapport.\nSi vous avez un erreur du type java.lang.OutOfMemoryError vous devez augmenter la taille mémoire de la machine virtuelle Java. Pour cela, sous Eclipse, suivez ce tutoriel: http://www.planetofbits.com/eclipse/increase-jvm-heap-size-in-eclipse/ . Par la suite, en ligne de commande, vous devrez ajouter l\u0026rsquo;option -Xms avec la valeur qui convient pour toutes les commandes java. Par exemple, java -Xms1000m pour avoir 1000Mo de mémoire alloués pour cette commande java.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"69376f9fc6f5ee899f076be069715fba","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape1/","section":"courses","summary":"Faire un programme séquentiel non parallélisé qui compte le nombre d'occurrences des mots dans un fichier. Prérequis et documentation   programmer en Java\nhttps://perso.telecom-paristech.fr/bellot/CoursJava/\n  manipuler l\u0026rsquo;environnement de développement Eclipse","tags":null,"title":"Etape 1","type":"docs"},{"authors":null,"categories":null,"content":"Travailler avec plusieurs ordinateurs en réseau. Prérequis et documentation   avoir un compte et pouvoir se connecter aux machines de l\u0026rsquo;école (contacter la DSI de l\u0026rsquo;école dans le cas contraire)\n  lancer un interpréteur de commande (console linux , shell) pour taper des commandes:\nhttps://fr.wikipedia.org/wiki/Interpréteur_de_commandes\nhttps://fr.wikipedia.org/wiki/Shell_Unix\n  connaître quelques commandes de base sous Linux\nhttps://fr.wikipedia.org/wiki/Commandes_Unix\n  https://prod-edx-mktg-edit.edx.org/course/linux-basics-the-command-line-interface   savoir qu\u0026rsquo;un ordinateur a un nom d\u0026rsquo;hôte (hostname) et plusieurs adresses IP:\nhttps://en.wikipedia.org/wiki/Hostname\nhttps://fr.wikipedia.org/wiki/Adresse_IP\n  savoir qu\u0026rsquo;un ordinateur peut faire partie d\u0026rsquo;un domaine (comme à l\u0026rsquo;école, le domaine enst.fr ou le domaine telecom-paristech.fr )\nhttps://fr.wikipedia.org/wiki/Nom_de_domaine\n  savoir qu\u0026rsquo;un nom peut être transformé en adresse IP (et inversement) par un serveur qui gère le système du nom de domaine (DNS, Domain Name System)\nhttps://fr.wikipedia.org/wiki/Domain_Name_System\n  se connecter à distance à un ordinateur avec SSH en ligne de commande\nhttps://fr.wikipedia.org/wiki/Secure_Shell\nhttp://www.commentcamarche.net/faq/74-se-connecter-a-distance-avec-ssh-linux\n  Nom court, nom long Quel est le nom COURT de votre ordinateur (le nom simple sans le domaine) ? quel est le nom LONG de votre ordinateur (le nom avec le domaine) ? Comment les connaître en ligne de commande ? Sur les ordinateurs de l\u0026rsquo;école, est-il possible d\u0026rsquo;obtenir ces noms autrement qu\u0026rsquo;en ligne de commande ? Ajoutez les réponses à votre rapport.\nAdresse ip Comment connaître les adresses (plusieurs) IP de votre ordinateur en ligne de commande ? Autrement (en passant par un site internet par exemple) ? Ajoutez les réponses à votre rapport.\nDu nom vers l\u0026rsquo;IP Comment à partir du nom d\u0026rsquo;un ordinateur, obtenir les adresses IP en ligne de commande ? Ajoutez les réponses à votre rapport.\nDe l\u0026rsquo;IP vers le nom Comment, à partir d\u0026rsquo;une adresse IP, obtenir les noms associés en ligne de commande ? Ajoutez les réponses à votre rapport.\nPing pong à l\u0026rsquo;intérieur! Testez la communication avec d\u0026rsquo;autres ordinateurs (pas le vôtre) depuis le réseau de l\u0026rsquo;école en utilisant la commande ping (pour arrêter le ping faire CTRL + C). suivi du nom court, du nom long, de l\u0026rsquo;IP. Les trois méthodes fonctionnent-elles ? Ajoutez les réponses à votre rapport.\nPing pong à l\u0026rsquo;extérieur Si vous effectuez le ping depuis un réseau différent, il est possible que celui ne fonctionne pas (filtrage des accès vers le réseau de l\u0026rsquo;école depuis un réseau extérieur), contactez la DSI pour mettre en place une connection VPN / OpenVPN afin d\u0026rsquo;être sur le même réseau que les machines en salle de TP.\nCalculer en ligne de commande sur l\u0026rsquo;ordinateur local Comment lancer un calcul en ligne de commande sur votre ordinateur (par exemple 2 + 3) ? Parmi les multiples réponses possibles, lesquelles permettent de lancer le calcul et d\u0026rsquo;obtenir le résultat en appuyant une seule fois sur la touche \u0026lt;Entrée\u0026gt; ? Ajoutez les réponses à votre rapport.\nCalculer en ligne de commande sur un ordinateur distant Comment lancer un calcul (par exemple 2 + 3) en ligne de commande sur un autre ordinateur (à distance) ? Il faudra certainement vous authentifier avec un mot de passe. Comment obtenir le résultat du calcul immédiatement après avoir tapé son mot de passe ? Ajoutez les réponses à votre rapport.\nCalculer à distance sans mot de passe Comment lancer un calcul à distance en utilisant SSH sans taper le mot de passe et en une seule ligne de commande (c\u0026rsquo;est à dire qu\u0026rsquo;on appuie sur \u0026lt;Entrée\u0026gt; et on a le résultat directement)?\nAttention: en utilisant vos ordinateurs personnels( a priori ce n\u0026rsquo;est pas le cas sur les ordinateurs de l\u0026rsquo;école), il faut parfois vérifier le \u0026ldquo;fingerprint\u0026rdquo; avec le message:\nThe authenticity of host 'mint.phcomp.co.uk (78.32.209.33)' can't be established.\nRSA key fingerprint is 6a🇩🇪e0:af:56:f8:0c:04:11:5b:ef:4d:49:ad:09:23.\nAre you sure you want to continue connecting (yes/no)? yes\nPour ne plus avoir à rentrer quoi que ce soit dans le terminal, il faut donc désactiver la vérification de ce \u0026ldquo;fingerprint\u0026rdquo;, sinon vous aurez l\u0026rsquo;erreur Host key verification failed\nSuivez ce guide pour désactiver la vérification de \u0026ldquo;fingerprint\u0026rdquo;:\nhttps://www.shellhacks.com/disable-ssh-host-key-checking/\nDe plus, si vous travaillez depuis votre ordinateur personnel, pour ne pas avoir à taper le mot de passe à chaque fois, il faut générer une clé privée et une clé publique SANS PASSPHRASE (ne pas mettre de mot de passe lors de la génération des clés) et installer la clé publique sur un ordinateur de l\u0026rsquo;école, en copiant le contenu de la clé publique dans le fichier authorized_keys. Ce fichier authorized_keys est a placer dans le dossier .ssh (attention, il y a un point devant ssh \u0026ldquo;.ssh\u0026rdquo;), lui même situé dans votre dossier personnel sur les machines de l\u0026rsquo;école. Pour cela, suivez un guide sur internet de création de clés publiques privées pour SSH. Attention, votre clé privée doit également être située dans le dossier .ssh de votre ordinateur personnel. La bonne configuration est donc: avoir une clé privée sur l\u0026rsquo;ordinateur personnel dans le dossier .ssh de votre ordinateur personnel et avoir une clé publique sur un ordinateur de l\u0026rsquo;école dans le dossier .ssh d\u0026rsquo;un ordinateur de l\u0026rsquo;école. Attention: sur Windows, il est parfois compliqué de créer le dossier .ssh. Sur Windows, il est également compliqué de générer des clés avec puttygen car le format des clés n\u0026rsquo;est pas compatible avec openssh utilisé à l\u0026rsquo;école. Puttygen a une option de conversion du format des clés (dans le menu conversions) pour convertir vers le fomat openssh. Le plus simple est de générer les clés sur une machine de l\u0026rsquo;école puis de copier la clé privée sur votre ordinateur perso plutôt que de générer la clé sur votre ordi perso... Demandez de l\u0026rsquo;aide à vos confrères experts en cas de pb. Ne restez pas coincé longtemps sur cette étape!\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"1fd56e7e1f58d25c1352093bb0fba9b2","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape2/","section":"courses","summary":"Travailler avec plusieurs ordinateurs en réseau. Prérequis et documentation   avoir un compte et pouvoir se connecter aux machines de l\u0026rsquo;école (contacter la DSI de l\u0026rsquo;école dans le cas contraire)","tags":null,"title":"Etape 2","type":"docs"},{"authors":null,"categories":null,"content":"Travailler avec des fichiers locaux ou sur un serveur NFS. Prérequis et documentation   pouvoir transférer un fichier d\u0026rsquo;un ordinateur à un autre en utilisant la commande SCP (Secure Copy): https://fr.wikipedia.org/wiki/Secure_copy   connaître l\u0026rsquo;architecture d\u0026rsquo;un système de fichier NFS (Network File System) : https://fr.wikipedia.org/wiki/Network_File_System   Chemin absolu Quel est le chemin absolu de votre répertoire personnel, votre home directory ? (commandes \u0026ldquo;cd\u0026rdquo; puis \u0026ldquo;pwd\u0026rdquo;)\nUn fichier dans le répertoire personnel Créez un fichier fperso.txt contenant le texte \u0026ldquo;bonjour\u0026rdquo; dans votre répertoire personnel (sur un ordinateur de l\u0026rsquo;école). Vérifiez le contenu du fichier avec cette commande exactement:\ncat ~/fperso.txt\nOu se trouve le fichier dans le répertoire personnel Ce fichier est-il sur le disque dur de l\u0026rsquo;ordinateur ou autre part ? Comment savoir où est stocké physiquement ce fichier, à l\u0026rsquo;aide de quelle commande ? Un dossier et un fichier dans le répertoire temporaire Créez un dossier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt; en remplaçant \u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt; (ne pas mettre les caractères \u0026lt; et \u0026gt; ).\nCréez un fichier ftemp.txt dans le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt; .\nVérifiez le contenu du fichier avec cette commande exactement:\ncat /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/ftemp.txt\nCe dossier et ce fichier sont-ils sur le disque dur de l\u0026rsquo;ordinateur ou autre part ? Comment savoir où sont stockés physiquement ces éléments, à l\u0026rsquo;aide de quelle commande ?\nTrois ordinateurs A B C. On commence avec A. Utilisation du serveur NFS. Pour les questions suivantes, utilisez trois ordinateurs: A, B C.\nConnectez vous physiquement (avec un clavier, une souris et un écran) sur l\u0026rsquo;ordinateur A.\nSur A, créez un fichier text.txt contenant le texte \u0026ldquo;mon texte sur NFS\u0026rdquo; dans votre répertoire personnel.\nVérifiez que le fichier existe et vérifiez son contenu. Pour cela, sur A, utilisez la commande :\ncat ~/text.txt\nTrois ordinateurs A B C. On continue sur B et sur C. Utilisation du serveur NFS. Connectez-vous à B (physiquement ou à distance) et vérifiez que le fichier text.txt est également présent dans votre répertoire personnel. Pour cela, sur B, utilisez la commande :\ncat ~/text.txt\nDe même, connectez-vous à C et vérifiez que text.txt est aussi présent.\nRemarquez que vous n\u0026rsquo;avez pas copié le fichier mais qu\u0026rsquo;il est présent sur A, B et C grâce au serveur NFS.\nTrois ordinateurs A B C. On commence avec A. Utilisation des disques locaux. Déconnectez vous de B et de C et revenez sur l\u0026rsquo;ordinateur A.\nSur A, créez un dossier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt; et un fichier local.txt contenant le texte \u0026ldquo;mon texte sur disque local\u0026rdquo; dans ce dossier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;.\nVérifiez que le fichier existe et vérifiez son contenu. Pour cela, sur A, utilisez la commande :\ncat /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/local.txt\nTrois ordinateurs A B C. On continue sur B et sur C. Utilisation des disques locaux. Connectez-vous à B et C (physiquement ou à distance) et vérifiez que le dossier \u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt; ainsi que le fichier local.txt ne sont pas présent dans /tmp . Pour cela vérifiez avec la commande:\nls /tmp\nDepuis A, copier de A vers B avec les disques locaux. Comment, à partir de A, transférer le fichier /tmp/local.txt sur B (dans /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/local.txt) en utilisant scp ? Vérifiez que le fichier est bien présent sur B. Attention: si vous avez une erreur \u0026ldquo;no such file or directory\u0026rdquo; (ou l\u0026rsquo;équivalent français), vous devez d\u0026rsquo;abord créer le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/ avec la commande mkdir -p associée à un ssh pour l\u0026rsquo;ordinateur distant.\nDepuis A, copier de B vers C avec les disques locaux. Comment, à partir de A, transférer le fichier de B (depuis /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/local.txt) vers C (dans /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/local.txt) ? Vérifiez que le fichier est bien présent sur C. De même que la question précédentes, vous devez créer les répertoires /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/ correspondants.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"d8c3677e9c1bdc74ef5b01262ba9d19b","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape3/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape3/","section":"courses","summary":"Travailler avec des fichiers locaux ou sur un serveur NFS. Prérequis et documentation   pouvoir transférer un fichier d\u0026rsquo;un ordinateur à un autre en utilisant la commande SCP (Secure Copy): https://fr.","tags":null,"title":"Etape 3","type":"docs"},{"authors":null,"categories":null,"content":"Lancer des programmes java à distance manuellement. Prérequis et documentation   exporter un .JAR exécutable (Runnable JAR File)\n  utiliser les packages et savoir lancer un programme Java en ligne de commande\n  Un premier programme SLAVE sous Eclipse Faire un programme Java nommé \u0026ldquo;SLAVE\u0026rdquo; qui calcule 3+5, affiche le résultat, sous Eclipse (Pour lancer Eclipse: Menu applications\u0026gt;développement), lancer ce programme dans Eclipse (flèche verte \u0026ldquo;exécuter\u0026rdquo;)\nExportation en JAR Exporter le programme Java en slave.jar exécutable (Java ARchive dite Runnable) sous Eclipse. Attention de bien vérifier que le JAR est de type \u0026ldquo;Runnable\u0026rdquo;/\u0026ldquo;exécutable\u0026rdquo;.\nExécution sur disque dur local Créez le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\nCopiez slave.jar exécutable dans le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\nTestez et Lancer le slave.jar en ligne de commande sur votre ordinateur local.\nCopie du JAR et exécution distante Depuis la machine A contenant /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/slave.jar Créez à distance sur la machine B (s\u0026rsquo;il n\u0026rsquo;existe pas) un répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\nCopiez slave.jar sur la machine B dans le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\nExécutez à distance (depuis A sur la machine B) le slave.jar.\nQuelle est la commande tapée pour effectuer cette dernière action ?\nAttention: si le JAR est créé sur votre machine personnelle, vous risquez de produire un JAR avec une version supérieure de JAVA que celle installée sur les ordinateurs de l\u0026rsquo;école. Pour remédier à ce problème, configurez votre projet JAVA pour qu\u0026rsquo;il soit compatible avec la version 1.8 de JAVA. Sous Eclipse, dans les propriétés de votre projet, allez dans Java Compiler et décochez la case \u0026ldquo;Use compliance from execution environment XXXX\u0026rdquo; et puis dans le menu déroulant choisissez 1.8. Vous devrez re-générer le JAR pour obtenir un JAR compatible avec la version 1.8 de Java.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"e65232a4acad6abdd1de42f86be68895","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape4/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape4/","section":"courses","summary":"Lancer des programmes java à distance manuellement. Prérequis et documentation   exporter un .JAR exécutable (Runnable JAR File)\n  utiliser les packages et savoir lancer un programme Java en ligne de commande","tags":null,"title":"Etape 4","type":"docs"},{"authors":null,"categories":null,"content":"Lancer des programmes en ligne de commande depuis java et afficher la sortie standard et la sortie d\u0026rsquo;erreur. Prérequis et documentation   utiliser le processBuilder en java\nhttp://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html .\n  lancer un exécutable (ou une commande) en ligne de commande depuis un programme écrit en java\n  connaître les sorties standard et les sorties d\u0026rsquo;erreurs\n  Un programme MASTER java qui lance un autre programme en ligne de commande! Ecrire un programme java nommé \u0026ldquo;MASTER\u0026rdquo; qui lance la commande suivante en utilisant ProcessBuilder:\nls -al /tmp\n(vous pouvez aussi tester cette commande dans un terminal avant)\nRécupérer et afficher la sortie de cette commande.\nVous devez utiliser ProcessBuilder de cette façon:\nProcessBuilder pb = new ProcessBuilder(\u0026quot;ls\u0026quot;, \u0026ldquo;-al\u0026rdquo;, \u0026ldquo;/tmp\u0026rdquo;);\nUn programme MASTER java qui gère les erreurs de lancement d\u0026rsquo;un autre programme en ligne de commande. Modifiez votre programme\u0026quot;MASTER\u0026rdquo; pour qu\u0026rsquo;il affiche la sortie d\u0026rsquo;erreur en cas d\u0026rsquo;erreur lors de l\u0026rsquo;exécution de la commande. Testez la sortie d\u0026rsquo;erreur avec une commande qui échoue avec un sortie d\u0026rsquo;erreur. Essayez par exemple d\u0026rsquo;exécuter la commande \u0026ldquo;ls /jesuisunhero\u0026rdquo;.\nExplications: si on tape la commande \u0026ldquo;ls /jesuiunhero\u0026rdquo;, le dossier /jesuisunhero n\u0026rsquo;existant pas, on aura une erreur de type \u0026ldquo;impossible d\u0026rsquo;accéder à /jesuisunhero: aucun fichier ou dossier de ce type.\u0026rdquo; qui s\u0026rsquo;affiche dans la sortie d\u0026rsquo;erreur. En effet, il y a deux sorties: les sorties standards (sans erreur) et les sorties d\u0026rsquo;erreurs.\nVous devez utiliser ProcessBuilder de cette façon:\nProcessBuilder pb = new ProcessBuilder(\u0026quot;ls\u0026quot;, \u0026quot;/jesuisunhero\u0026rdquo;);\nSur pb, vous pouvez récupérer le flux de la sortie standard et le flux de la sortie d\u0026rsquo;erreur.\nUn programme MASTER java qui lance un slave.jar en ligne de commande. Modifiez votre programme \u0026ldquo;MASTER\u0026rdquo; pour qu\u0026rsquo;il lance \u0026ldquo;SLAVE\u0026rdquo;, c\u0026rsquo;est à dire slave.jar situé sur la même machine que \u0026ldquo;MASTER\u0026rdquo; dans le dossier\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/slave.jar\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"4d2a5bcf543f80466892834aebb255b9","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape5/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape5/","section":"courses","summary":"Lancer des programmes en ligne de commande depuis java et afficher la sortie standard et la sortie d\u0026rsquo;erreur. Prérequis et documentation   utiliser le processBuilder en java\nhttp://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html .","tags":null,"title":"Etape 5","type":"docs"},{"authors":null,"categories":null,"content":"Gérer les timeout du MASTER. Un SLAVE qui simule un calcul de 10 secondes. Modifiez votre programme SLAVE pour qu\u0026rsquo;il simule une attente de 10 secondes avant d\u0026rsquo;afficher le résultat du calcul 3+5. Pour cela utilisez\nThread.sleep(10000); Vérifiez le bon fonctionnement du SLAVE et constatez qu\u0026rsquo;il y a 10 secondes entre le démarrage du SLAVE et l\u0026rsquo;affichage du résultat. Attention de ne rien afficher avant les 10 secondes pour que la question suivante fonctionne correctement.\nGénérez de nouveau le slave.jar. Copiez-le en écrasant le slave.jar dans le dossier\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/slave.jar\nTestez le lancement à partir de MASTER.\nGérer les timeout au niveau du MASTER. Modifier le MASTER pour qu\u0026rsquo;il attende que quelque chose soit écrit dans la sortie standard (sans erreur) ou dans la sortie d\u0026rsquo;erreurs du SLAVE pendant un certain temps maximum. Au bout du temps imparti le MASTER considère un timeout.\nIl arrête les éventuels threads (si vous utilisez des threads - non obligatoire) s\u0026rsquo;occupant des sorties et/ou stoppe le processus créé avec ProcessBuilder.\nVous avez la solution ci-dessous pour implémenter les TESTs suivants:\nTEST1 : calcul 10 secondes et timetout 2 secondes Testez le bon fonctionnement du timeout en lançant le SLAVE avec un timeout de 2 secondes sur les sorties (standard et d\u0026rsquo;erreur). Le timeout étant plus court (au niveau du MASTER 2 secondes) que le temps de calcul du SLAVE (10 secondes), le MASTER doit arrêter les éventuels threads (si vous en utilisez) et le processus.\nTEST 2: calcul 10 secondes et timeout 15 secondes Testez ensuite avec un timeout de 15 secondes, il ne devrait pas y avoir de timeout.\nTEST 3: sortie d\u0026rsquo;erreur Testez ensuite en changeant le SLAVE pour qu\u0026rsquo;il écrive non plus dans la sortie standard (sans erreur) mais dans la sortie d\u0026rsquo;erreur. Pour cela, remplacez dans le Slave les System.out.print\u0026hellip; par System.err.print\u0026hellip;\nSOLUTION 1 (très difficile) passez à la SOLUTION 2 si vous êtes débutant\nVous utilisez deux threads (processus légers) pour chaque processus lourd (lancé avec ProcessBuilder). Un thread s\u0026rsquo;occupe de lire la sortie standard et l\u0026rsquo;autre la sortie d\u0026rsquo;erreur. Une solution pour gérer les timeout consiste à utiliser une structure ArrayBlockingQueue (taille fixe) ou LinkedBlockingQueue (taille dynamique) donnée en paramètre de chaque thread s\u0026rsquo;occupant de lire la sortie standard (sans erreur) ou la sortie d\u0026rsquo;erreur. Chaque thread va écrire ce qui est lu depuis les sorties dans cette structure en utilisant la méthode put. Le timeout de 2 secondes peut alors être paramétré lors de la récupération des éléments insérés dans la structure en utilisant la méthode poll sur l\u0026rsquo;ArrayBlockingQueue ou la LinkedBlockingQueue de cette manière:\npoll(2, TimeUnit.SECONDS);\nSOLUTION 2 (très facile) La solution 3 est facile si vous voulez voir.\nUne solution consiste à:\n rediriger la sortie d\u0026rsquo;erreur dans la sortie standard à l\u0026rsquo;aide de la méthode pb.redirectErrorStream(true) du ProcessBuilder utiliser pb.inheritIO(); pour rediriger les sorties du process dans le MASTER (c\u0026rsquo;est à dire que le MASTER va afficher les sorties du SLAVE). Attention pb.inheritIO() doit être appelé AVANT pb.start(); démarrer le process avec Process p = pb.start(); attendre la fin du process avec un waitFor sur le process qui génère un timeout en utilisant boolean b = p.waitFor(3, TimeUnit.SECONDS); //si b vaut false il y a un timeout s\u0026rsquo;il y a un timeout vous devez détruire le process avec p.destroy();  Attention: dans cette solution et l\u0026rsquo;utilisation de inheritIO() , vous ne pourrez plus récupérer et/ou traiter la sortie standard ou la sortie d\u0026rsquo;erreur du process: par exemple, p.getInputStream() renverra un flux vide et p.getErrorStream() renverra aussi un flux vide.\nSOLUTION 3 (facile ) Il s\u0026rsquo;agit d\u0026rsquo;utiliser pb.redirectErrorStream(true) et une boucle pour lire les lignes reçues depuis p.getInputStream() sans utiliser inheritIO()\nSOLUTION 4 (moins facile ) il s\u0026rsquo;agit d\u0026rsquo;utiliser deux boucles pour lire les lignes reçues depuis p.getInputStream() et p.getErrorStream() sans utiliser inheritIO()\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"b4988e793d0f8341cfa1720c39d514bf","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape6/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape6/","section":"courses","summary":"Gérer les timeout du MASTER. Un SLAVE qui simule un calcul de 10 secondes. Modifiez votre programme SLAVE pour qu\u0026rsquo;il simule une attente de 10 secondes avant d\u0026rsquo;afficher le résultat du calcul 3+5.","tags":null,"title":"Etape 6","type":"docs"},{"authors":null,"categories":null,"content":"Déployer automatiquement le programme SLAVE sur un ensemble de machines. Un programme DEPLOY : Test de connection SSH multiple Créer un fichier texte à la main contenant : les adresses IP et/ou les noms des machines que nous voulons utiliser pour notre système réparti (par exemple toutes les machines de cette salle de TP), avec un nom ou une IP par ligne dans le fichier.\nCréer un nouveau programme java DEPLOY qui lit ce fichier ligne par ligne et teste si la connection SSH fonctionne bien sur chacune des machines. Attention, il s\u0026rsquo;agit bien d\u0026rsquo;un nouveau programme qui est séparé de MASTER ou SLAVE, vous ne l\u0026rsquo;exécuterez qu\u0026rsquo;en cas de mise à jour du SLAVE. Ceci permet de vérifier qu\u0026rsquo;une machine n\u0026rsquo;est pas éteinte ou qu\u0026rsquo;il y a un problème de connection (par exemple).\nPour vérifier que la connection fonctionne bien, vous pouvez faire afficher le nom de la machine distante (en exécutant la commande hostname à distance) et vérifier que l\u0026rsquo;affichage a effectivement lieu, sans erreurs. Réutilisez des parties de codes de la cinquième étape.\nVotre programme DEPLOY lance-t-il les connections de manière séquentielle (les unes après les autres) ou de manière parallèle?\nUn programme DEPLOY : copie de slave.jar multiple Modifier votre programme DEPLOY pour qu\u0026rsquo;il copie le slave.jar dans /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/ sur les ordinateurs dont la connection SSH fonctionne.\nPour cela, vous devez utiliser la commande mkdir -p pour créer les répertoires dans /tmp s\u0026rsquo;ils n\u0026rsquo;existent pas déjà, attendre que le mkdir se termine puis copier avec scp le fichier slave.jar. Comment faites-vous pour attendre que le mkdir se termine correctement?\nVérifiez ensuite manuellement que le fichier a bien été copié sur les ordinateurs distants.\nAttention de bien attendre la fin du mkdir avant de lancer le scp (on ne veut pas avoir de copie avant que le dossier soit effectivement créé).\nLors des copies, faites attention au caractère \u0026quot; / \u0026quot; à la fin d\u0026rsquo;un chemin :\n /tmp/toto est un chemin vers un fichier nommé toto\n/tmp/toto/ est un chemin vers un dossier nommé toto.\nVotre programme DEPLOY lance-t-il les copies de manière séquentielle (les unes après les autres) ou de manière parallèle?\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"3ee9a04d8cf21fd954ec01b40e2d310a","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape7/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape7/","section":"courses","summary":"Déployer automatiquement le programme SLAVE sur un ensemble de machines. Un programme DEPLOY : Test de connection SSH multiple Créer un fichier texte à la main contenant : les adresses IP et/ou les noms des machines que nous voulons utiliser pour notre système réparti (par exemple toutes les machines de cette salle de TP), avec un nom ou une IP par ligne dans le fichier.","tags":null,"title":"Etape 7","type":"docs"},{"authors":null,"categories":null,"content":"Nettoyer un ensemble de machines avec CLEAN. Un programme \u0026ldquo;CLEAN\u0026rdquo; qui nettoie les machines distantes. Créez un nouveau programme CLEAN (différent de MASTER, SLAVE ou DEPLOY) qui efface votre dossier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/sur les ordinateurs dont la connection SSH fonctionne. Pour cela, vous utiliserez le même fichier texte écrit à la main et utilisé par DEPLOY contenant : les adresses IP et/ou les noms des machines que nous voulons utiliser pour notre système réparti (par exemple toutes les machines de cette salle de TP), avec un nom ou une IP par ligne dans le fichier.\nCLEAN lit ce fichier ligne par ligne et efface sur chacune des machines votre dossier créé dans le dossier temporaire, en lançant la commande à distance rm -rf /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/. Attention de bien attendre la fin de la commande rm -rf pour être sûr que l\u0026rsquo;effacement a bien été effectué.\nVotre programme CLEAN lance-t-il les commande d\u0026rsquo;effacement de manière séquentielle (les unes après les autres) ou de manière parallèle?\nVérification du DEPLOY et du CLEAN Vérifiez manuellement que l\u0026rsquo;effacement des dossiers a bien lieu. Ce programme vous permet de nettoyer un ensemble de machines avant de relancer un calcul. A partir de maintenant, vous pouvez déployer votre application en utilisant DEPLOY et vous pouvez nettoyer votre application en utilisant CLEAN. Vérifiez donc que DEPLOY suivi CLEAN fonctionne correctement.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"0a46c7a729034afff7b664b58ca3b202","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape8/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape8/","section":"courses","summary":"Nettoyer un ensemble de machines avec CLEAN. Un programme \u0026ldquo;CLEAN\u0026rdquo; qui nettoie les machines distantes. Créez un nouveau programme CLEAN (différent de MASTER, SLAVE ou DEPLOY) qui efface votre dossier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/sur les ordinateurs dont la connection SSH fonctionne.","tags":null,"title":"Etape 8","type":"docs"},{"authors":null,"categories":null,"content":"Lancer le programme SLAVE sur un ordinateur à distance. CLEAN et DEPLOY Faites un CLEAN. Faites un DEPLOY sur une seule machine (modifier la liste des machines pour n\u0026rsquo;en mettre qu\u0026rsquo;une) . Vous devriez avoir la dernière version de slave.jar déployée sur une seule machine.\nMaster lançant Slave à distance. Modifier votre programme \u0026ldquo;MASTER\u0026rdquo; pour qu\u0026rsquo;il lance à distance le programme \u0026ldquo;SLAVE\u0026rdquo; déjà déployé avec le programme \u0026ldquo;DEPLOY\u0026rdquo; sur la seule machine distante.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"e7518b90acb98e2713026114bf80d234","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape9/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape9/","section":"courses","summary":"Lancer le programme SLAVE sur un ordinateur à distance. CLEAN et DEPLOY Faites un CLEAN. Faites un DEPLOY sur une seule machine (modifier la liste des machines pour n\u0026rsquo;en mettre qu\u0026rsquo;une) .","tags":null,"title":"Etape 9","type":"docs"},{"authors":null,"categories":null,"content":"MapReduce - SPLIT et MAP Prérequis et documentation pour les questions suivantes :   connaître l\u0026rsquo; architecture de MapReduce\n  Connaître la convention des nom des fichiers pour notre TP\n  connaître le vocabulaire: S UM SM RM (Splits, Unsorted Maps, Sorted Maps, Reduced Maps) - voir en cours\n  Un MASTER qui déploie les splits Créez trois fichiers correspondants à des \u0026ldquo;splits\u0026rdquo; dans le répertoire temporaire. Dans un premier temps, créez ces fichiers manuellement.  /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/splits\nS0.txt S1.txt S2.txt.\nS0.txt contient:\nDeer Beer River\nS1.txt contient:\nCar Car River\nS2.txt contient:\nDeer Car Beer\nModifiez votre MASTER pour qu\u0026rsquo;il copie les 3 fichiers de splits dans 3 ordinateurs différents, en ne copiant qu\u0026rsquo;un slip par machine. Par exemple, s\u0026rsquo;il existe 3 machines et 3 splits, la première machine aura le premier split, la deuxième le deuxième etc. Pour cela vous utiliserez le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet.\nAttention, le répertoire /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/splits doit être créé sur les 3 ordinateurs s\u0026rsquo;il n\u0026rsquo;existe pas. Cette création peut se faire de manière automatique (en créant de manière programmatique ces répertoires). Attention de faire attention de bien attendre que la création des dossiers soit bien effectuée avant de lancer la copie des splits. Comment attendez-vous que la création des dossiers soit bien effectuée avant de copier véritablement les fichiers?\nDe la même manière que le programme DEPLOY, le MASTER va copier ces splits vers 3 ordinateurs dont la connection SSH fonctionne.\nVotre programme MASTER lance-t-il les copies de manière séquentielle (les unes après les autres) ou de manière parallèle?\nUn SLAVE qui fait la phase de map Modifiez le SLAVE pour qu\u0026rsquo;il calcule un map à partir d\u0026rsquo;un split.\nPour cela, il prend un mode de fonctionnement en argument: 0 correspond au calcul du map à partir d\u0026rsquo;un split, puis un nom de fichier \u0026ldquo;Sx.txt\u0026rdquo; en entrée depuis le dossier splits et calcule un fichier \u0026ldquo;UMx.txt\u0026rdquo; en sortie dans le dossier maps, avec x variant (ici de 1 à 3). De la même manière que précédemment, le dossier maps doit être créé avant de pouvoir écrire des fichiers dedans. Vous devez attendre que le dossier maps soit créé avant de travailler avec. Comment attendez-vous que le dossier maps soit bien créé avant de travailler avec?\nLe nom du fichier sera donné comme argument args du main:\npublic static void main (String[] args)\nTestez dans un terminal le slave.jar comme suit:\ncd /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\njava -jar slave.jar 0 /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/splits/S0.txt\nLe fichier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/maps/UM0.txt doit être créé contenant\nDear 1\nBeer 1\nRiver 1\nTestez le fonctionnement de votre SLAVE avec le fichier S1.txt contenant\nCar Car River\nTestez dans un terminal le JAR comme suit:\ncd /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\njava -jar slave.jar 0 /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/splits/S1.txt\nLe fichier /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/maps/UM1.txt doit être créé contenant\nCar 1\nCar 1\nRiver 1\nAttention: Comme votre SLAVE est modifié, utilisez le DEPLOY pour déployer la nouvelle version.\nPosez-vous la question: pourquoi retrouvons-nous deux lignes\nCar 1\nCar 1\nAu lieu d\u0026rsquo;une seule ligne\nCar 2\nUn indice: la phase de reduce qui arrivera plus tard, fera une addition des valeurs. Dans ce cas, la \u0026ldquo;fonction\u0026rdquo; de reduce est très simple: c\u0026rsquo;est une grande addition. Imaginez une fonction de reduce beaucoup plus complexe qui effectue un algorithme complexe appliqué sur toutes les valeurs...\nUn MASTER qui lance les SLAVE pour la phase de map. Modifiez le MASTER pour qu\u0026rsquo;il lance la phase de map sur plusieurs machines et affiche \u0026ldquo;MAP FINISHED\u0026rdquo;. Pour cela vous utiliserez le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet.\nPour bien synchroniser le MASTER avec les SLAVES, veillez à afficher \u0026ldquo;MAP FINISHED\u0026rdquo; qu\u0026rsquo;une fois tous les SLAVEs terminés et uniquement quand tous les SLAVEs sont terminés, PAS AVANT! Le MASTER doit donc attendre que SLAVEs se terminent correctement.\nComment faites-vous pour qu\u0026rsquo;un process lancé avec ProcessBuilder en Java attende la fin de l\u0026rsquo;exécution du processus ?\nVotre programme MASTER lance-t-il les SLAVE de manière séquentielle (les uns après les autres) ou de manière parallèle?\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"c3165e104fa587a301d4fde5632de814","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape10/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape10/","section":"courses","summary":"MapReduce - SPLIT et MAP Prérequis et documentation pour les questions suivantes :   connaître l\u0026rsquo; architecture de MapReduce\n  Connaître la convention des nom des fichiers pour notre TP","tags":null,"title":"Etape 10","type":"docs"},{"authors":null,"categories":null,"content":"MapReduce - SHUFFLE Le MASTER qui prépare les SLAVE à la phase de shuffle. Modifiez le MASTER pour qu\u0026rsquo;il envoie le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet à tous les SLAVES utilisés pour la phase de map. Copiez ce fichier dans la cible suivante pour tous les SLAVES:\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/machines.txt\nLe SLAVE qui prépare la phase de shuffle. Modifiez le SLAVE pour qu\u0026rsquo;il prépare la phase de shuffle en regroupant les clés, en calculant le \u0026ldquo;hash\u0026rdquo; pour chacune des clés et en créant un fichier ayant pour nom \u0026lt;hash\u0026gt;-\u0026lt;hostname\u0026gt;.txt dans le dossier shuffles. De la même manière que précédemment, le dossier shuffles doit être créé avant de pouvoir écrire des fichiers dedans. Vous devez attendre que le dossier shuffles soit créé avant de travailler avec. Comment attendez-vous que le dossier shuffles soit bien créé avant de travailler avec?\nLe nom du fichier sera donné comme argument args du main:\npublic static void main (String[] args)\nAttention: si le fichier \u0026lt;hash\u0026gt;-\u0026lt;hostname\u0026gt;.txt existe déjà, il ne faut pas l\u0026rsquo;écraser mais plutôt continuer d\u0026rsquo;écrire dedans.\nCe nom de fichier correspond au hash, obtenu grâce à la fonction de hashage de la classe String, explications ici fonction de hachage de la classe java.lang.String , calculé à partir de la clé; Le nom de la machine, lui, est obtenu grâce à l\u0026rsquo;instruction java suivante: java.net.InetAddress.getLocalHost().getHostName()\nPour cela, votre SLAVE prend un mode de fonctionnement en argument: 1 , qui correspond au calcul du hash , puis un nom de fichier \u0026ldquo;UMx.txt\u0026rdquo; en entrée depuis le dossier maps et calcule un fichier \u0026ldquo;\u0026lt;hash\u0026gt;-\u0026lt;hostname\u0026gt;.txt \u0026quot; en sortie dans le dossier shuffles. Gardez le mode précédent: 0 pour la phase de map.\nTestez le fonctionnement de votre SLAVE avec le fichier UM1.txt contenant\nCar 1\nCar 1\nRiver 1\nTestez dans un terminal le JAR comme suit:\ncd /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\njava -jar slave.jar 1 /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/maps/UM1.txt\nLes fichiers suivants doivent être créés:\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shuffles/67508-c127-12.txt créé contenant\nCar 1\nCar 1\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shuffles/78973420-c127-12.txt créé contenant\nRiver 1\nComme votre SLAVE est modifié, utilisez le DEPLOY pour déployer la nouvelle version.\nLe SLAVE qui exécute la phase de shuffle. Modifiez le SLAVE pour qu\u0026rsquo;il exécute la phase de shuffle.\nPour cela, pour chaque clé calculée lors du map, en plus de créer le fichier dans le dossier shuffles, il faut envoyer ce fichier dans le dossier shufflesreceived d\u0026rsquo;une des machines du fichier\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/machines.txt\nPour savoir sur quelle machine il faut l\u0026rsquo;envoyer, on utilise le hash calculé à partir de la clé (une valeur entière) et le nombre de machines du fichier. Il suffit de calculer le hash modulo le nombre de machine en considérant que la première machine du fichier a pour numéro 0, la deuxième 1 etc... La formule utilisée pour trouver la machine sur laquelle sera envoyée le shuffle sera donc\nnumeroMachine = hash % nbMachines\nDe plus, si le dossier shufflesreceived n\u0026rsquo;existe pas sur la machine réceptrice, il faudra le créer, attendre la fin de sa création, puis envoyer les fichiers dans ce dossier.\nTestez le fonctionnement de votre SLAVE avec le fichier UM1.txt contenant\nCar 1\nCar 1\nRiver 1\net le fichier machine.txt contenant uniquement TROIS machines (on fera donc un modulo 3)\nTestez dans un terminal le JAR comme suit:\ncd /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\njava -jar slave.jar 1 /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/maps/UM1.txt\nLes fichiers suivants doivent être créés:\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shuffles/67508-c127-12.txt créé contenant\nCar 1\nCar 1\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shuffles/78973420-c127-12.txt créé contenant\nRiver 1\nNormalement, le fichier 67508-c127-12.txt doit être copié dans la machine numéro 2 (67508 modulo 3 = 2) dans le dossier shufflesreceived\net le fichier 78973420-c127-12.txt doit être copié dans la machine numéro 1 (78973420 modulo 3 = 1) dans le dossier shufflesreceived\nComme votre SLAVE est modifié, utilisez le DEPLOY pour déployer la nouvelle version.\nUn MASTER qui lance et attend la fin de la phase de shuffle. Modifiez le MASTER pour qu\u0026rsquo;il lance la phase de shuffle une fois que la phase de map est terminée, sur plusieurs machines et affiche \u0026ldquo;SHUFFLE FINISHED\u0026rdquo;. Pour cela vous utiliserez le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet.\nPour bien synchroniser le MASTER avec les SLAVES, veillez à afficher \u0026ldquo;SHUFFLE FINISHED\u0026rdquo; qu\u0026rsquo;une fois tous les SLAVEs terminés et uniquement quand tous les SLAVEs sont terminés, PAS AVANT! Le MASTER doit donc attendre que SLAVEs se terminent correctement.\nComment faites-vous pour qu\u0026rsquo;un process lancé avec ProcessBuilder en Java attende la fin de l\u0026rsquo;exécution du processus ?\nVotre programme MASTER lance-t-il les SLAVE de manière séquentielle (les uns après les autres) ou de manière parallèle?\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"27489feae6fc4b8df61b936492dfdf08","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape11/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape11/","section":"courses","summary":"MapReduce - SHUFFLE Le MASTER qui prépare les SLAVE à la phase de shuffle. Modifiez le MASTER pour qu\u0026rsquo;il envoie le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet à tous les SLAVES utilisés pour la phase de map.","tags":null,"title":"Etape 11","type":"docs"},{"authors":null,"categories":null,"content":"MapReduce - REDUCE Le SLAVE qui exécute la phase de reduce. Modifiez le SLAVE pour qu\u0026rsquo;il prépare la phase de reduce en regroupant les fichiers avec le même hash, en calculant le reduce pour chacune des clés et en créant un fichier ayant pour nom \u0026lt;hash\u0026gt;.txt dans le dossier reduces. De la même manière que précédemment, le dossier reduces doit être créé avant de pouvoir écrire des fichiers dedans.\nPour cela, votre SLAVE prend un mode de fonctionnement en argument: 2 , qui correspond au calcul du reduce. Gardez les modes précédents: 0 pour la phase de map, 1 pour la phase de shuffle.\nTestez le fonctionnement de votre SLAVE avec les fichiers suivants DANS LE DOSSIER SHUFFLERECEIVED\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shufflesreceived/67508-cxxx-12.txt contenant\nCar 1\nCar 1\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shufflesreceived/67508-cxxx-13.txt contenant\nCar 1\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/shufflesreceived/78973420-cxxx-12.txt contenant\nRiver 1\nTestez dans un terminal le JAR comme suit:\ncd /tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/\njava -jar slave.jar 2\nLe dossier reduces doit contenir les fichiers suivants:\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/reduces/67508.txt contenant\nCar 3\n/tmp/\u0026lt;votre nom d\u0026rsquo;utilisateur\u0026gt;/reduces/78973420.txt contenant\nRiver 1\nComme votre SLAVE est modifié, utilisez le DEPLOY pour déployer la nouvelle version.\nUn MASTER qui lance et attend la fin de la phase de reduce . Modifiez le MASTER pour qu\u0026rsquo;il lance la phase de reduce une fois que la phase de shuffle est terminée, sur plusieurs machines et affiche \u0026ldquo;REDUCE FINISHED\u0026rdquo;. Pour cela vous utiliserez le fichier précédemment créé qui contient la liste des machines que vous voulez utiliser pour votre projet.\nPour bien synchroniser le MASTER avec les SLAVES, veillez à afficher \u0026ldquo;REDUCE FINISHED\u0026rdquo; qu\u0026rsquo;une fois tous les SLAVEs terminés et uniquement quand tous les SLAVEs sont terminés, PAS AVANT! Le MASTER doit donc attendre que SLAVEs se terminent correctement.\nUn MASTER qui chronomètre les phases. Modifiez le MASTER pour qu\u0026rsquo;il chronomètre les différentes phases MAP, SHUFFLE, REDUCE et pour qu\u0026rsquo;il affiche le temps de chacune des phases.\nTestez sur l\u0026rsquo;exemple de départ avec les trois splits suivants:\nS0.txt S1.txt S2.txt.\nS0.txt contient:\nDeer Beer River\nS1.txt contient:\nCar Car River\nS2.txt contient:\nDeer Car Beer\nQuelle est la phase qui prend le plus de temps ? Quelle est la phase la plus rapide ?\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"45dcd40e960923f1b50a7d479bbe645c","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape12/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape12/","section":"courses","summary":"MapReduce - REDUCE Le SLAVE qui exécute la phase de reduce. Modifiez le SLAVE pour qu\u0026rsquo;il prépare la phase de reduce en regroupant les fichiers avec le même hash, en calculant le reduce pour chacune des clés et en créant un fichier ayant pour nom \u0026lt;hash\u0026gt;.","tags":null,"title":"Etape 12","type":"docs"},{"authors":null,"categories":null,"content":"MapReduce - finalisations et optimisations Un MASTER qui affiche le résultat à partir d\u0026rsquo;un fichier input.txt Modifiez le MASTER pour qu\u0026rsquo;il crée les splits et les déploies sur plusieurs machines à partir d\u0026rsquo;un fichier input.txt et affiche le résultat final (la combinaison des résultats dans les dossiers reduces des différentes machines).\nUn projet Hadoop-Mapreduce complet, utilisable en environnement \u0026ldquo;BigData\u0026rdquo; Copiez votre projet tel qu\u0026rsquo;il est à la question précédente. Ceci vous permet de garder une version de votre projet qui fonctionne avec l\u0026rsquo;exemple de démo tel que décrit lors des questions précédentes (petit fichier input.txt de démo avec 3 lignes).\nAméliorez la copie de votre projet pour qu\u0026rsquo;il fonctionne avec des plus gros fichiers en input.\nUne prise en compte des pannes De la même manière que précédemment, créez une copie de votre projet sur laquelle vous travaillez sur la robustesse: faites en sorte que votre programme fonctionne malgré des pannes inopinées de certaines machines. Pour tester, vous pouvez éteindre une ou plusieurs machines au milieu de calculs. Vous pouvez inventer d\u0026rsquo;autres pannes vous-même et présenter vos résultats. Comparez avec la méthode de robustesse utilisée par Google : https://research.google.com/archive/mapreduce-osdi04.pdf ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"8e60f9b81b661d1054caf4efe5fff45c","permalink":"https://remisharrock.fr/courses/simple-hadoop-mapreduce-from-scratch/etape13/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/simple-hadoop-mapreduce-from-scratch/etape13/","section":"courses","summary":"MapReduce - finalisations et optimisations Un MASTER qui affiche le résultat à partir d\u0026rsquo;un fichier input.txt Modifiez le MASTER pour qu\u0026rsquo;il crée les splits et les déploies sur plusieurs machines à partir d\u0026rsquo;un fichier input.","tags":null,"title":"Etape 13","type":"docs"},{"authors":[],"categories":[],"content":"Table of Contents  3 innovative tools implemented in MOOCs to enhance teaching and learning of C programming with Linux:  Codecast Taskgrader WebLinux   Some of my use cases Demos in conferences Project contributors Project made by With the support of   How to make early beginners learning programming easier? The goal for our international team is to enhance learning with in-browser open-source coding tools, providing easy onboarding and a rich learning experience for learners. Using a variety of tools, we aim to facilitate active learning style computer science teaching and learning. We began with the assumption that it is impossible to learn how to program with multiple choice assessments. Thus, we designed tools and assessments that allow students to learn by programming, via interactive and intuitive tools.\n3 innovative tools implemented in MOOCs to enhance teaching and learning of C programming with Linux: Codecast How to overcome the barrier that a programming screencast video tutorial is not interactive? How to better teach and explain to learners basics of computer programming such as pointers, memory allocation or matrices in an online environment at large scale?\nAny CS educator has to explain sooner or later a portion of code or a structured text to learners. The Codecast tool has been specially designed by CS educators and developed for MOOCs to replace non-interactive screencasts.\nTaskgrader Taskgrader is an automated grader to assess code submissions at scale, providing customized feedback, embedded in the platform with LTI. In these courses, we developed tasks within the Taskgrader platform to provide hands-on coding challenges in which learners apply knowledge presented in the codecasts by the instructor. The learner writes and submits a program and then receives detailed feedback and a score within seconds. To promote mastery learning, students can request hints and receive unlimited attempts. Learners can edit and resubmit until they complete the task. This setup is made to support motivation and learner engagement.\nWebLinux Teaching Linux in an online environment brings challenges. One of them is to provide a easy onboarding experience for learners. How to make Linux available easily to users who might not be able to download large files on their own device or be skilled enough to install a Linux OS on their own device? The Weblinux tool provides a Linux OS fully in the browser and solves the inconvenient problem of having to install an ISO disc image or provide access to a virtual machine.\nSome of my use cases   2 MOOC offered on FUN-MOOC, French national Open edX instance.  7 MOOC offered on edX.org  Demos in conferences   Demo paper presented at the Learning@Scale conference, Forth annual SCM Conference, April 2017, MIT, Cambridge. // Poster presentation  Workshop organized at the SIGCSE \u0026lsquo;18 conference, 49th ACM Technical Symposium on Computer Science Education, February 2018, Baltimore. Demo presentation at the OpenedX Conference, May 2018, UMontreal.  Demo paper presented at Learning@Scale conference, Fifth Annual ACM Conference on Learning at Scale, June 2018, London   Project contributors   Rémi Sharrock (Télécom ParisTech)  Mathias Hiron (France IOI) Sébastien Carlier (Epixode) Michel Blockelet (France ioi) Elie Roux (France ioi) Lawrence Angrave (University of Illinois at Urbana-Champaign)  Ella Hamonic (Independent researcher) Baptiste Gaultier (IMT Atlantique) Petra Bonfert-Taylor (Dartmouth College) Michael Goudzwaard (Dartmouth College) Chris Miller (Dartmouth College) Gérard Memmi (Télécom ParisTech)  Project made by    \nWith the support of ","date":1588085434,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588085434,"objectID":"de66ee0ce9232504bb0984f0828a2a4e","permalink":"https://remisharrock.fr/project/codecast/","publishdate":"2020-04-28T16:50:34+02:00","relpermalink":"/project/codecast/","section":"project","summary":"Codecast is a powerfull and inovative tool for teaching and learning how to code.","tags":[],"title":"Codecast","type":"project"},{"authors":[],"categories":[],"content":"Sometimes I convert HTML pages extracted from websites to Markdown using Pandoc. Here is an example using this command:\npandoc -s -r html https://codecast.wp.imt.fr/ -o codecast.md  The problem is that it often generates extra information following the pattern\n[interesting text that I want to keep]{uninteresting parameters extracted from HTML that I want to delete}  for example:\n[Any CS educator has to explain sooner or later a portion of code or a structured text to learners. The Codecast tool has been specially designed by CS educators and developed for MOOCs to replace non-interactive screencasts.]{style=\u0026quot;font-weight: 400\u0026quot;}  I found an easy way to clean the Markdown using Visual Studio Code \u0026ldquo;find and replace\u0026rdquo; feature with regex. Here is the regular expression that I used:\n^\\[([\\s\\S\\r]*?)\\]\\{.*\\}  The ^ means beginning of a line. If you want to find this pattern in the middle of lines, just delete it.\nThe \\[ \\] means that I want to search something between squared brackets.\nThe [\\s\\S\\r] means a whitespace character \\s (space, tab\u0026hellip;) OR a character that is not a whitespace \\S (a,b,c\u0026hellip;) OR a new line character \\r. Note that in Visual Studio Code regex system, the \\s does NOT include the new line (even if I would think it\u0026rsquo;s a whitespace character), that\u0026rsquo;s why I specifically add the \\r.\nThe (x*?) - here x is the expression just above - asks to capture a group using ( and ) , with the character x appearing zero or more times with * and once or none with ?. Maybe you are lost at this point! Anyway, because we asked for a capture, we will be able to use $1 as a variable containing the captured text!\nThe \\{.*\\} means curly braces with something inside - Here I could also use [\\s\\S\\r] instead of .*\nAnyway, I then replace with $1 and here is the result:\n","date":1588029771,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588029771,"objectID":"298540e9b6e49ed66f00a78a697a9b5f","permalink":"https://remisharrock.fr/post/regex-search-and-replace-visual-studio-code/","publishdate":"2020-04-28T01:22:51+02:00","relpermalink":"/post/regex-search-and-replace-visual-studio-code/","section":"post","summary":"Sometimes I convert HTML pages extracted from websites to Markdown using Pandoc. Here is an example using this command:\npandoc -s -r html https://codecast.wp.imt.fr/ -o codecast.md  The problem is that it often generates extra information following the pattern","tags":[],"title":"Search and replace using regex in Visual Studio Code","type":"post"},{"authors":[],"categories":[],"content":"So here is my first blog post switching from an old static website generator to a new one called Hugo and a theme called academic. I stated creating static sites in 2015 with a generator integrated to GitHub called Jekyll and hosted (for free) using github pages. For the techies, you can see the move happened with this very commit.\nI think my old website will still be accessible in the future using the wayback machine to get some details on how it was previously built, maybe you can check (beware: as soon as you click the link, you will be travelling back in time!) by clicking here. For those of you who are afraid to click, and that is understandable (you wouldn\u0026rsquo;t want to be lost in a parallel universe would you), you will notice a slight difference in the URL of the website. Indeed, I used HTTP and not HTTPS, remember that the S stands for Secured, what a crazy idea! As google wrote in a post back in 2018:\n For the past several years, we’ve moved toward a more secure web by strongly advocating that sites adopt HTTPS encryption. And within the last year, we’ve also helped users understand that HTTP sites are not secure by gradually marking a larger subset of HTTP pages as “not secure”. Beginning in July 2018 with the release of Chrome 68, Chrome will mark all HTTP sites as “not secure”.\n Of course Google was right and I was surprised to discover that sites load slower using HTTP rather than HTTPS, even if you think the added encryption mechanism would slower things down: isn\u0026rsquo;t that counterintuitive ? Take a look here to understand.\nLooking back at my \u0026ldquo;behind the scenes of this website\u0026rdquo; I also mentioned ATOM to be my source code editor, which is not the case anymore. I switched to Visual Studio Code and I\u0026rsquo;m very happy with it. Anyway the funny ATOM launching video is still on YouTube and I still like it a lot, especially when grandma switches the colors to black and green 👵 💻! No comparable video for Visual Studio Code 😏.\nFor the rest, I still use GitHub pages and I\u0026rsquo;ll explore more differences in a new post one day!\n","date":1587937721,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587937721,"objectID":"f0e9db2a79820eb8d50e757210425a6d","permalink":"https://remisharrock.fr/post/starting-my-academic-page/","publishdate":"2020-04-26T23:48:41+02:00","relpermalink":"/post/starting-my-academic-page/","section":"post","summary":"So here is my first blog post switching from an old static website generator to a new one called Hugo and a theme called academic. I stated creating static sites in 2015 with a generator integrated to GitHub called Jekyll and hosted (for free) using github pages.","tags":[],"title":"Starting My (New) Academic Page","type":"post"}]